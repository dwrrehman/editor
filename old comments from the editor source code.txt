














		// alternate keybinding for movement:





			en   eo    ep    ei         for begin, end, top and bottom

			ek     column jump

			el 	line jump

			l    o   	for word movement 

		
			n u p i       for char movement 

			
							g y   for character searching? .... hmmm not sure about this one

		
		

			k is a dead stop key for something

							or opens a command window, im not sure

										yeah, probably a command text line, so that you can send a command. 

				instead of ":"     like in vim


					so yeah

							now we have "h" as a dead stop  key again   yayy


							


					and also        a         might also be a dead stop 



										not sure 




								but we also have c and v    those are dual seq too


							

								and i think thats it




					basically, i want to remove all capital letters. thats my goal. 



							use only dead stops, where it makes sense. 


								so yeah. 



	basically, the rule of thumb is, if you are going to be pressing it  mulitple times in a row,  quite often,  then you need a single key
		but if not, it can be a dual seq with some deadstop key     for ergonomic combinations that make sense, of course. 


				the goal is for them to be done with one hand, always. its one movement.



						much like how workman does things, lol


						so yeah




	

		heres the keys that we are using mainly, in the editor.   trying not to make too many exceptions. 
			these are the keys that are ergonomic to type. 


		  d r             u p 
		a s h t         n e o i 
		     m c       k l 


	

	








if ((0)) {

	FILE* file = fopen("slow-unit-51c51b79e2d54f513d863e36641ae7045c1f8e22", "r");
	if (not file) { perror("open"); exit(1); }
	fseek(file, 0, SEEK_END);
	size_t crash_length = (size_t) ftell(file);
	char* crash = malloc(sizeof(char) * crash_length);
	fseek(file, 0, SEEK_SET);
	fread(crash, sizeof(char), crash_length, file);
	fclose(file);
	_input = (const uint8_t*) crash;
	_input_count = crash_length;
	printf("\n\n\nstr = \"");
	for (size_t i = 0; i < _input_count; i++) printf("\\x%02hhx", _input[i]);
	printf("\";\n\n\n");

	exit(1);


} 
if ((0)) {

	const char* str = "\x09\x77\x72\x77\x2c\x7a";

	_input = (const uint8_t*) str;
	// _input_count = strlen(str);
	_input_count = 1000;
}

*/








// static nat scroll_counter = 0;

	// DONE:    TODO: make it so pressing escape once is sufficient.

	// if (stdin_is_empty()) sprintf(message, "stdin buffer is empty!");
	// also add mouse support so that you can click to reposition the cursor. 






		// todo: add    esc [ 2004 l       :   disable bracketed paste mode. because we arent babies, and dont care about copy paste attacks. 

		// note:  we already have:  1049h   : switch to the alternate screen. 

		//







// FILE* file = fopen("crash-b019392511ce17e97e5710b3e737866f804f99f3", "r");
	// if (not file) { perror("open"); exit(1); }
	// fseek(file, 0, SEEK_END);
	// size_t crash_length = (size_t) ftell(file);
	// char* crash = malloc(sizeof(char) * crash_length);
	// fseek(file, 0, SEEK_SET);
	// fread(crash, sizeof(char), crash_length, file);
	// fclose(file);
	// input = (const uint8_t*) crash;
	// input_count = crash_length;
	// printf("\n\n\nstr = \"");
	// for (size_t i = 0; i < input_count; i++) printf("\\x%02hhx", input[i]);
	// printf("\";\n\n\n");
	// exit(1);

	// const char* str = "\x74\x43\x72\x77\x74\x92\x72\x77\x58\x78\x74\x72\x77\x78\x7a";

	// input = (const uint8_t*) str;
	// input_count = strlen(str);
	// input_count = 1000;






/*

	todo: 
--------------------------


f	- file manager and tab completion

f	- config file for init values.

f	- tc isa!!


		
	- make the machine code virtual machine interpreter:


		- implement the editor ISA, 
		- figure out how to allow for it to be TC.
		- make it ergonmic for a human to type, while being fast/efficient and minimalist.
		
			- - then later on, we can make the scripting language which will compile to the editor ISA machine code.


		- - easy to use by design,
		- - allow for repitions and macros by design,
		- - allow for commands with arbitary spelling
		- - extensible command context/enviornments,
		- - unified command system: buffer commands vs prompted commands. 




--------------------------------------------------------
			DONE:
--------------------------------------------------------


	features:
----------------------------


	x	- make the line numbers and column numbers 0-based everywhere. just do it. 

	x	- make scroll counter a local static variable in the internpret escape code function.

	x	- write the delete_buffers and delete_lines functions. 

	x	- we need to put most of the state for the registers that's not essential in a buffer data structure. 

	x	- make the code use "nat"'s instead of int's.    using the typedef:   // typedef nat ssize_t; 

	x	- redo the undo-tree code so that it uses a flat array datastructure- not a pointer based tree. 

	x	- make a simple and robust copy/paste system, that can support system clipboard.

	bugs:
----------------------------

	x 	- this editor has a HUGE memory leak. we need to fix this.

	x	- negative size param, delete(), from cut(). 

	x	- memory leak because of x:undo(); 

	x	- a possible crashing bug of undo()/move_left(), although i'm not sure yet...

	x 	- vdc not correct, with unicode.  



///////////////////////////////// old code //////////////////////////////////////////////

// static inline void recalculate_position() {    // used when we modify wrap or tab width. i think...
// 	int save_lcl = lcl, save_lcc = lcc;
// 	move_top();
// 	adjust_window_size();
// 	jump_line(save_lcl);
// 	jump_column(save_lcc);
// }

	// FILE* file = fopen("crash-c6c6ea3f9acfd5ca8ebcbb8e7e3e17846aca32bb", "r");
	// fseek(file, 0, SEEK_END);        
	// size_t crash_length = (size_t) ftell(file);
	// char* crash = malloc(sizeof(char) * crash_length);
	// fseek(file, 0, SEEK_SET);
	// fread(crash, sizeof(char), crash_length, file);
	// fclose(file);
	// input = (const uint8_t*) crash;
	// input_count = crash_length;
	// printf("\n\n\nstr = \"");
	// for (size_t i = 0; i < input_count; i++) printf("\\x%02hhx", input[i]);
	// printf("\";\n\n\n");
	// exit(1);

	// const char* str = "x\r\r\r\xfc\x01\x79\x72\x77\x58\x61\x65\x72\x65\x76\x72";
	// input = (const uint8_t*) str;
	// input_count = strlen(str);


	// const char* str = "jufat\xa8ufrzE";   

	// c  <exit>  anchor   insertmode    <unicode>    <exit>      cut       undo      jump@col0



00	REDUCE cov: 1183 ft: 8920 corp: 1230/93Kb lim: 958 exec/s: 614 rss: 1452Mb L: 129/871 MS: 1 EraseBytes-
#833346	REDUCE cov: 1183 ft: 8920 corp: 1230/93Kb lim: 967 exec/s: 613 rss: 1452Mb L: 28/871 MS: 1 EraseBytes-
=================================================================
==58956==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x000116f40c72 at pc 0x000102b33900 bp 0x00016d2dd380 sp 0x00016d2dd378
READ of size 1 at 0x000116f40c72 thread T0
    #0 0x102b338fc in move_left main.c:189
    #1 0x102b31df8 in delete main.c:474
    #2 0x102b37474 in reverse_action main.c:1257
    #3 0x102b36678 in undo main.c:1269
    #4 0x102b27c4c in execute main.c:1335
    #5 0x102b225bc in editor main.c:1432
    #6 0x102b222d8 in LLVMFuzzerTestOneInput main.c:1454
    #7 0x102b5fa3c in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) FuzzerLoop.cpp:611
    #8 0x102b5f21c in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) FuzzerLoop.cpp:514
    #9 0x102b60898 in fuzzer::Fuzzer::MutateAndTestOne() FuzzerLoop.cpp:757
    #10 0x102b614d0 in fuzzer::Fuzzer::Loop(std::__1::vector<fuzzer::SizedFile, fuzzer::fuzzer_allocator<fuzzer::SizedFile> >&) FuzzerLoop.cpp:895
    #11 0x102b51bb4 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) FuzzerDriver.cpp:906
    #12 0x102b794f8 in main FuzzerMain.cpp:20
    #13 0x102d290f0 in start+0x204 (dyld:arm64+0x50f0)
    #14 0x8a16fffffffffffc  (<unknown module>)

0x000116f40c72 is located 0 bytes to the right of 2-byte region [0x000116f40c70,0x000116f40c72)
allocated by thread T0 here:
    #0 0x10301394c in wrap_realloc+0x94 (libclang_rt.asan_osx_dynamic.dylib:arm64+0x3f94c)
    #1 0x102b2e750 in insert main.c:407
    #2 0x102b37bac in reverse_action main.c:1261
    #3 0x102b36678 in undo main.c:1269
    #4 0x102b27c4c in execute main.c:1335
    #5 0x102b225bc in editor main.c:1432
    #6 0x102b222d8 in LLVMFuzzerTestOneInput main.c:1454
    #7 0x102b5fa3c in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) FuzzerLoop.cpp:611
    #8 0x102b5f21c in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool, bool*) FuzzerLoop.cpp:514
    #9 0x102b60898 in fuzzer::Fuzzer::MutateAndTestOne() FuzzerLoop.cpp:757
    #10 0x102b614d0 in fuzzer::Fuzzer::Loop(std::__1::vector<fuzzer::SizedFile, fuzzer::fuzzer_allocator<fuzzer::SizedFile> >&) FuzzerLoop.cpp:895
    #11 0x102b51bb4 in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) FuzzerDriver.cpp:906
    #12 0x102b794f8 in main FuzzerMain.cpp:20
    #13 0x102d290f0 in start+0x204 (dyld:arm64+0x50f0)
    #14 0x8a16fffffffffffc  (<unknown module>)

SUMMARY: AddressSanitizer: heap-buffer-overflow main.c:189 in move_left
Shadow bytes around the buggy address:
  0x007022e08130: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fa fa
  0x007022e08140: fa fa fa fa fa fa fd fa fa fa fa fa fa fa fd fa
  0x007022e08150: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x007022e08160: fa fa fd fa fa fa fa fa fa fa fd fa fa fa fd fa
  0x007022e08170: fa fa fa fa fa fa fd fa fa fa fd fa fa fa fd fa
=>0x007022e08180: fa fa fd fa fa fa fd fa fa fa fa fa fa fa[02]fa
  0x007022e08190: fa fa fa fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x007022e081a0: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x007022e081b0: fa fa 04 fa fa fa fd fa fa fa fd fa fa fa fd fa
  0x007022e081c0: fa fa fd fa fa fa fd fa fa fa 00 fa fa fa fd fa
  0x007022e081d0: fa fa fd fa fa fa fa fa fa fa fd fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07 
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==58956==ABORTING
MS: 1 CrossOver-; base unit: 511a5fd4707ac55efabed80447aa2932a6e4a86c
0x9,0x6c,0xd1,0xd1,0x7f,0x21,0xd,0xff,0x86,0xff,0x2c,0x2d,0x54,0x2c,0x77,0x9,0x61,0x77,0x72,0x9,0x77,0x0,0x9,0x9,0x0,0x0,0x0,0x25,0xd1,0x7b,0x72,0x77,0x9,0x61,0x77,0x45,0x78,0x72,0x28,0x78,0x8,0x70,0x6f,0x72,0x74,0x7f,0x7f,0xd3,0x76,0x85,0x7a,0xfd,0x72,0x77,0x9d,0x46,0x0,0x7a,0x7a,0x77,0x9d,0x46,0xfd,0x72,0x77,0x9d,0x46,0x0,0x7a,0x7a,0x33,0x78,0x72,0x7a,0x72,0x77,0x67,0x67,0x7a,0x67,0x67,0x7a,0x77,0x9d,0x46,0xfd,0x72,0x77,0x9d,0x46,0x0,0x7a,0x7a,0x33,0x78,0x72,0x7a,0x7a,0x35,0x78,0x92,0x81,0x0,
\x09l\xd1\xd1\x7f!\x0d\xff\x86\xff,-T,w\x09awr\x09w\x00\x09\x09\x00\x00\x00%\xd1{rw\x09awExr(x\x08port\x7f\x7f\xd3v\x85z\xfdrw\x9dF\x00zzw\x9dF\xfdrw\x9dF\x00zz3xrzrwggzggzw\x9dF\xfdrw\x9dF\x00zz3xrzz5x\x92\x81\x00
artifact_prefix='./'; Test unit written to ./crash-e26e7bb6538311c641076a3de56cd36a03b67851
Base64: CWzR0X8hDf+G/ywtVCx3CWF3cgl3AAkJAAAAJdF7cncJYXdFeHIoeAhwb3J0f3/TdoV6/XJ3nUYAenp3nUb9cnedRgB6ejN4cnpyd2dnemdnenedRv1yd51GAHp6M3hyeno1eJKBAA==
zsh: abort      


	// const char* str = "Ú—grwet\x97rwzr";

	//  <unicode>    g      <exit>    word-left      insertmode      <unicode>    <exit>     undo    cut



















  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
==63825==ABORTING
MS: 2 ChangeASCIIInt-CopyPart-; base unit: 68cfcc9ba8ac3a3d18faeaee33f6f960c50db109
0xa,0x89,0xff,0x6e,0x73,0x74,0x92,0x72,0x77,0x58,0x50,0x43,0x9,0xa,0xa,0xa,0x73,0x74,0x92,0x72,0x77,0x58,0x50,0x43,0x9,0xff,0x3d,0xff,0xff,0xd,0x72,0x77,0x5a,0x7a,0x77,0xac,0x78,0x21,0x7a,0x5a,0x7a,0x77,0xac,0x78,0x21,0x7a,0x77,0xac,0x78,0x33,0x0,0x0,0x73,0x74,0x92,0x72,0x77,0x58,0xe2,0x50,0x43,0x9,0xff,0xff,0x77,0xac,0x78,0x33,0x0,0x0,0x73,0x74,0x92,0x72,0x77,0x58,0xe2,0x50,0x43,0x9,0xff,0xff,0xff,0xff,0xd,0x72,0x77,0x5a,0x7a,0x77,0xac,0x78,0x21,0x7a,0x77,0xac,0x78,0x32,0x0,0x0,0x0,0x0,0xac,0x78,0x21,0x7a,0x7f,0xbe,
\x0a\x89\xffnst\x92rwXPC\x09\x0a\x0a\x0ast\x92rwXPC\x09\xff=\xff\xff\x0drwZzw\xacx!zZzw\xacx!zw\xacx3\x00\x00st\x92rwX\xe2PC\x09\xff\xffw\xacx3\x00\x00st\x92rwX\xe2PC\x09\xff\xff\xff\xff\x0drwZzw\xacx!zw\xacx2\x00\x00\x00\x00\xacx!z\x7f\xbe
artifact_prefix='./'; Test unit written to ./crash-b019392511ce17e97e5710b3e737866f804f99f3
Base64: Con/bnN0knJ3WFBDCQoKCnN0knJ3WFBDCf89//8NcndaeneseCF6Wnp3rHgheneseDMAAHN0knJ3WOJQQwn//3eseDMAAHN0knJ3WOJQQwn/////DXJ3Wnp3rHgheneseDIAAAAArHghen++
zsh: abort      ./editor







	// const char* str = "\x2d\x2c\x72\x77\x61\x74\x7f\x7f\xd3\x76\x85\x72\x77\x72\x7a\x7a";






	// const char* str = "ttrwat\x7f\x7fgv\x85rwrzz";


	//0     char   char   <exit>    

	//1     anchor   insertmode    

	//0     <backspace>   <backspace>     char    char    <unicode>    <exit>

	//1     cut     undo   undo 








	// const char* str = "ttrwt\x92rwXxtrwxz";  

	//             char   char               exit   

	//        insertmode   unicode           exit    

	//        alternatedown    redo    

	//        insertmode                     exit   

	//        redo   undo 


*/








/*




static inline void move_left(bool change_desired) {
	if (not lcc) {
		if (not lcl) return;
		lcl--; 
		lcc = lines[lcl].count;
visual_line_up: compute_vcc();
visual_just_line_up: vcl--;
		if (vsl) vsl--;
		else if (vol) vol--;
		if (vcc > window_columns - line_number_width) { 
			vsc = window_columns - line_number_width; 
			voc = vcc - vsc; 
		} else { 
			vsc = vcc;
			voc = 0; 
		}
	} else {
		nat save_lcc = lcc;
		do lcc--; while (lcc and zero_width(lines[lcl].data[lcc]));
		if (lines[lcl].data[lcc] == '\t') {
			

			compute_vcc();
			nat old_vcc = vcc;
			for (nat c = lcc; c < save_lcc; c++) {
				char k = lines[lcl].data[c];
				if (old_vcc >= wrap_width) goto visual_just_line_up;
				if (k == '\t') {
					do {
						if (old_vcc >= wrap_width) goto visual_just_line_up; 
						old_vcc++; 
					} while (old_vcc % tab_width); 
				} else if (visual(k)) old_vcc++;
			}
			nat diff = old_vcc - vcc;
			if (vsc >= diff) vsc -= diff;
			else if (voc >= diff - vsc) { voc -= diff - vsc; vsc = 0; }






		} else {
			if (not vcc) goto visual_line_up;
			vcc--; 
			if (vsc) vsc--; 
			else if (voc) voc--;
		}
	}
	if (change_desired) vdc = vcc;
}



nat line = 0, col = 0; 
	// this is not correct!  ---> we need to compute the logical version of VOC and VOL, and start here.

	nat vl = vol, vc = voc; 
	// i think these should be initialized to    VOL and VOC,       i think. 

	nat sl = 0, sc = 0; 



*/






	// we cannot start out at zero, for the vc and vl,  or the line and col. 

	// we actually need to try to START AT THE CURSOR,
	//	(because we know that IT  is    AT LEAST     pretttttttyyyyy cloooossssseeeeee    to what we want. i think. 
	
	// and so, we can actually start at the cursor, and try to work backwards, (or search backwards, i mean)
	// to try to find the Logical Column and Logical Line that corresponds with VO(L/C) (Visual Origin line and col),  
	//  which is the crucial piece of information we need to start rendering. we need to know where in the text to 
	// start printing out text from, and we know that position must be where ever VOL lands, in logical coordinates. 

	// so yeah, thats how we get the performance of vim, in our scrolling, and display rendering, i think. that should do it. 


	// so how do we compute the logical coordinates of VO(L/C)?   (VOL and VOC)



	// this crucially releis on using the already existing piece of info,      vcc  and vcl 

	// these two variables are          the visual cursor line/col

	//      and they represent    the position of the cursor, in visual coordinates.  which the VOL and VOC are also based in. 

	//      and so, like, we know what  the visual coordinates of the logical cursor are now. 


	/// so heres the train of translations we need to do:

	//         logical/visual cursor --->  move backwards char-wise in logical space, and keep track of your visual coords while doing it, (utilize "compute_vcc()"!!!). once you notice that your visual coords hit "VOL" and "VOC",   then note down what resultant logical coords you had to go to in order to reach this visual position, from the cursor. 

	// that is what you need to initialize the variables "line" and "col" to. 


	// additionally,    "vc" and "vl"       should now be initialized to   VOC    and  VOL.      which makes sense. 

	// and sc and sl are still initialized to 0. thats totally good. 


	// yay! we figured it out, basically. cool. moving backwards is always more computationally expensive than moving forward, i think, but this is definitely the right way to go, i think. yayyyyyyyyyyy

	//  okay turns out i think we can literally use "move_left" to do most of the work for us!! as long as we revert back everything the way we found it lol. 







	// int n = 0;
	// if (ioctl(0, I_NREAD, &n) == 0) {
 //    		// we have exactly n bytes to read
	// 	sprintf(message, "info we have exactly %d bytes to read.",n);
	// }

	// n = 1;
	// if (ioctl(0, I_NREAD, &n) == 0 && n > 0) {
 //    		// we have exactly n bytes to read
	// 	sprintf(message, "info we have exactly %d bytes to read.",n);
	// }

	// n = 2;
	// if (ioctl(0, I_NREAD, &n) == 0 && n > 0) {
 //    		// we have exactly n bytes to read
	// 	sprintf(message, "info we have exactly %d bytes to read.",n);
	// }

	// n = 3;
	// if (ioctl(0, I_NREAD, &n) == 0 && n > 0) {
 //    		// we have exactly n bytes to read
	// 	sprintf(message, "info we have exactly %d bytes to read.",n);
	// }








//	n	n	n	n	n	n	n	n	n	n	n	n	n	n	n	n	n	n		
//ntntntntnttntnntntntntntnttntnntntntntntnttntnntntntntntnttntnntntntntntnttntnntntntntntnttntnntntntntntnttntnntntntntntnttntnntntntntntnttntnegegett	








/*




			//todo: simplify this?...


			compute_vcc();
			nat old_vcc = vcc;
			for (nat c = lcc; c < save_lcc; c++) {
				char k = lines[lcl].data[c];
				if (old_vcc >= wrap_width) goto visual_just_line_up;
				if (k == '\t') {
					do {
						if (old_vcc >= wrap_width) goto visual_just_line_up; 
						old_vcc++; 
					} while (old_vcc % tab_width); 
				} else if (visual(k)) old_vcc++;
			}



			nat diff = old_vcc - vcc;
			if (vsc >= diff) vsc -= diff;
			else if (voc >= diff - vsc) { voc -= diff - vsc; vsc = 0; }













*/








//vt100 reference material: 
//
//    https://www2.ccs.neu.edu/research/gpc/VonaUtils/vona/terminal/vtansi.htm
//











// nat after_vcc = compute_custom_vcc(lcc);
			// nat before_vcc = compute_custom_vcc(save_lcc);
			// if (after_vcc > before_vcc) after_vcc = 0;      
			// =0, because:  to put back after to be on the same line. ie, before it wrapped back to the previous line.   
			// if "(after > before)", then it must be that our after_vcc is on the line above, 
			//                        and before_vcc are on the line below
			// ashtLNNN	ashoetn
			// compute_custom_vcc(lcc); 


			// int n = 0;
			// n++;



/*


	big bug with tabs and wraping:





okay, so i thought i figured out the bug, with this, and got the correct solution, and when i run it in the debugger, it seems to run pretty good, and do the correct thing, when going back on a tab that is being wrapped because of the wrap width, 

			but then i ran it in release mode, and it still goes into an infinite loop... 


				so i am not sure whats happening..... i think it has to do with the other movement commands?... not sure though... 

						hmmm


		








	editor`::__sanitizer_cov_trace_const_cmp8() at FuzzerTracePC.cpp:495:1 [opt]
    	frame #1: 0x000000010000d298 editor`move_left(change_desired=false) at main.c:241:10
    	frame #2: 0x0000000100008d64 editor`display at main.c:603:66
    	frame #3: 0x0000000100001ef8 editor`editor(_input="\t\t\t\t\t\xc1", _input_count=6) at main.c:1544:3
    	frame #4: 0x0000000100001dcc editor`LLVMFuzzerTestOneInput(input="\t\t\t\t\t\xc1", size=6) at main.c:1575:2


	




			if (vcc + 1 <= wrap_width) {
				vcc++; 
				if (vsc < window_columns - 1 - line_number_width) vsc++; 
				else voc++;
			} else {
				vcl++; vcc = 0; voc = 0; vsc = 0;
				if (vsl < window_rows - 1 - show_status) vsl++; 
				else vol++;
			}





							if (wrap_width <= tab_width) break; 
							
							if (vcc >= wrap_width) {
								vcl++; vcc = 0; voc = 0; vsc = 0;
								if (vsl < window_rows - 1 - show_status) vsl++; 
								else vol++;
							}










// if (vc >= wrap_width) goto next_visual_line;      // do a dictoch on "<=ww" here and in tab section too.

// delete me 









			if (vcc + (tab_width - vcc % tab_width) <= wrap_width) {
				do {
					vcc++; if (vsc < window_columns - 1 - line_number_width) vsc++; else voc++;
				} while (vcc % tab_width); 
			} else {
				vcl++; vcc = 0; voc = 0; vsc = 0;
				if (vsl < window_rows - 1 - show_status) vsl++; 
				else vol++;
			}




			if (vcc + 1 <= wrap_width) {
				vcc++; 
				if (vsc < window_columns - 1 - line_number_width) vsc++; 
				else voc++;
			} else {
				vcl++; vcc = 0; voc = 0; vsc = 0;
				if (vsl < window_rows - 1 - show_status) vsl++; 
				else vol++;
			}

